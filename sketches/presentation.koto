from ohm import *
from pitches import *
from scales import *

#-
 ▄▄▄  ▐▌   ▄▄▄▄  
█   █ ▐▌   █ █ █ 
▀▄▄▄▀ ▐▛▀▚▖█   █ 
      ▐▌ ▐▌

audio live coding 
   environment
-#

out = sin 0

#
# DEMO TIME!
#

# hat = |r| 
#   mod = ((lfo (lfo 0.2) * 3) * 5000) + 1000
#   rel = r -> seq [10000, 20000, 3000]
#   (noise() -> bp mod) * r -> ar rel
#
# f1 = ramp 0.1 -> seq [-0.5, 0.5, 1]
# f2 = ramp f1 -> seq [1, 3, 9, 2, 5, 7]
# trig = ramp (f2 / 5)
# hh = hat trig -> rev 0.2
#
# kick = |r| 
#   ((((ar r) ^ 3) * 50) + 10 -> sin) ^ 8
#
# f4 = ramp 0.2 -> seq [-0.5, 0.5, 1]
# f3 = ramp f4 -> seq [1, 7, 5]
# bd = kick ramp f3
#
# synth = ||
#   trig = (ramp (lfo 0.1) * 0.2) ^ 2
#   freq =  trig -> seq [100, 200, 500, 400]
#   cutoff = (trig * 2.2) % 1 -> seq [500, 2000, 300] -> onepole 0.99
#   saw freq -> moog cutoff, 0.6
#
# bass = || ramp 0.25 -> seq [25, 50] -> saw -> moog 500
#
# mix = (bd * 0.1) + (hh * 0.4) + (bass() * 0.4) + ((synth() -> rev 0.3) * 0.5)

#-
contents:
1 inspiration
2 design goals
3 features
4 implementation
5 future plans
-#

#-
1. inspiration

- Csound, SuperCollider, Max/Pd, TidalCycles/Strudel, ChucK, etc.
- different levels of abstraction
  - visual vs textual
  - events vs signals
  - prototyping vs live-oriented
- Rust, Koto, FunDSP
#-

#-
2. design goals

- be able to express musical ideas elegantly and concisely
- stay in the flow
- terse/minimal syntax
- interpreted / realtime / sound doesn't stop
- dynamically typed
- no distinction between audio and control signals
- open design
- sensible defaults
-#

# saw() -> lp 100, 2.717

#-
2. features
-#
# built-in audio nodes:
# oscillators (sine, saw, square, triangle, noise)
# sin(100) * 0.1

# filters (svf, moog, onepole)
# saw(100) -> lp 1000, 2

# envelopes
# trig = ramp 1.5
# saw(100) * ar trig

# fx (reverb, delay, flanger, etc.)
# trig = ramp 0.5
# (saw(100) * ar trig) -> flanger -> rev

# sequencer
# trig = ramp 1.5
# freq = trig -> seq [C3, E3, G3, B2] -> ptof
# saw(freq) -> lp 1000

# audio file playback
# atmo = file "reso2"
# ramp 0.09 -> play atmo

# sample buffers
# b = buf sr
# x = saw 100 -> rec b
# y = ramp 0.3 -> play b
# x + y

# abstraction (functions)
# hat = |r| noise() * (ar r -> pow 32) -> bp 10000
# hat ramp 1

# arithmetic/logical operators
# utility functions (ftop, etc.)
# useful constants (pitches, scales, pi, sample rate)
# A4
# MAJ

# Koto: pipe operator
# lp(saw(100))

# saw 100 -> lp

# osc

# filter

# envelope
# trig = ramp 0.5
# saw(100) * ar trig

# fx
# trig = ramp 0.5
# saw(100) * ar trig -> flanger -> rev

# hz = ramp(4) -> seq [900, 200]
# sin hz

# ramp-based timing (instead of pulse)
#   bend/reverse/expand time
# r = ramp 0.5
# r = ramp 0.5 -> ramp_rev -> ramp_mul 2
# r -> seq [C3, E3, C4, D5] -> ptof -> saw -> lp

# hot reloading w/ state preservation
hz = lfo(0.1) * 100 + 100
sin hz

#-
3. implementation
  - file watching / hot reloading
  - audio graph
  - graph diffing
    - copy state of (stateful) nodes
  - stereo signals
-#

#-
4. future plans
  - multichannel signals
  - Ableton Link
  - MIDI input
  - moar nodes: generative, spectral fx, etc.
  - master bus
  - visual feedback (neovim plugins?)
  - web/WASM version
  - optimization
    - process block instead of single samples
    - JIT-compile audio graph
    - parallelize
-#

# https://github.com/cornedriesprong/ohm
# 
# THANK YOU!
#

