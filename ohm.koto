from pitches import *

export A4_FREQ = 440

export C_MAJ = [0, 2, 4, 5, 7, 9, 11]
export C_MIN = [0, 2, 3, 5, 7, 8, 10]

export ar = |trig, release = 10000| trig -> env [(1, 0), (0, release)]
export lfo = |hz = 0.1| sin(hz) * 0.5 + 0.5

export lp = |x, hz = 500, q = 0.717| x -> svf "lp", hz, q
export bp = |x, hz = 500, q = 0.717| x -> svf "bp", hz, q
export hp = |x, hz = 500, q = 0.717| x -> svf "hp", hz, q
export notch = |x, hz = 500, q = 0.717| x -> svf "notch", hz, q
export peak = |x, hz = 500, q = 0.717| x -> svf "peak", hz, q
export allpass = |x, hz = 500, q = 0.717| x -> svf "ap", hz, q

export mix = |xs| 
  xs.fold 0, |acc, x| x * (1 / xs.count()) + acc

export rev = |x, mix = 0.5 | 
  (x * (1 - mix)) + ((x -> reverb) * mix)

export flanger = |x, mix = 0.5, amt = 0.5, speed = 0.1| 
  dry = x * (1 - mix)
  wet = (((x -> delay (lfo speed) * (amt * 1000)) + x) * 0.5) * mix
  dry + wet

# a one pole IIR filter, useful for smoothing signals
export onepole = |x, a = 0.5|
  # define a single sample buffer
  b = buf 1
  # tap the buffer one sample ago
  y = tap b, 1
  # feed the input + the delayed signal back into the buffer
  x = (x * (1 - a) + (y * a)) -> rec b
  x + y

# one zero FIR filter
export fir = |x, a = 0.5|
  (x * (1 - a)) + ((x -> delay 1) * a)

export echo = |x, t = sr / 3, fb = 0.5, damping = 0.5|
  b = buf()
  y = tap b, t
  y = y -> onepole damping
  x = x + (y * fb) -> rec b
  x + y

export echo_stereo = |x, t = sr / 3, fb = 0.5, damping = 0.5|
  ch = |offset|
    b = buf()
    delayed = tap b, t + offset -> onepole damping
    wet = x + (delayed * fb) -> rec b
    wet + delayed

  (ch 100 -> pan -1) + (ch -100 -> pan 1)

export pluck = |t, pitch, length = 1, damping = 0.5|
  period = freq_to_period (ptof pitch)
  noise() * ar 500, t -> echo period, length, damping

export bseq = |trigs, trig|
  let values = trigs.transform |x| if x == true then 1 else 0
  seq(values, trig)

