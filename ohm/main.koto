from bjorklund import *
from pitches import *

#
# constants
# 
export A4_FREQ = 440

#
# sequencers
# 

# euclidean sequence
export eseq = |ramp, pulses, steps| ramp -> seq euclid pulses, steps

#
# filters
# 
export lp = |x, hz = 500, q = 0.707| x -> svf "lp", hz, q
export bp = |x, hz = 500, q = 0.707| x -> svf "bp", hz, q
export hp = |x, hz = 500, q = 0.707| x -> svf "hp", hz, q
export notch = |x, hz = 500, q = 0.707| x -> svf "notch", hz, q
export peak = |x, hz = 500, q = 0.707| x -> svf "peak", hz, q
export allpass = |x, hz = 500, q = 0.707| x -> svf "ap", hz, q

# one pole IIR filter, useful for smoothing signals
export onepole = |x, a = 0.5|
  # define a single sample buffer
  b = buf 1
  # tap the buffer one sample ago
  y = tap b, 1
  # feed the input + the delayed signal back into the buffer
  x = (x * (1 - a) + (y * a)) -> rec b
  x + y

# one zero FIR filter
export fir = |x, a = 0.5|
  (x * (1 - a)) + ((x -> delay 1) * a)

#
# envelopes
#

# low-pass gate
export lpg = |x, ramp, amt = 8000, curve = 3|
  freq = ramp -> ramp_rev -> pow curve -> mul amt
  q = 1
  x -> lp freq, q

#
# utilities
#
export add = |lhs, rhs| lhs + rhs
export sub = |lhs, rhs| lhs - rhs
export mul = |lhs, rhs| lhs * rhs
export div = |lhs, rhs| lhs / rhs
export pow = |lhs, rhs = 2| lhs ^ rhs
export mod = |lhs, rhs = 1| lhs % rhs

# ramp utilities

# reverse ramp
export ramp_rev = |x| if x == 0 then 0 else x * -1 + 1
export subdiv = |x, ratio = 2| x * ratio % 1 

# conversions

# pitch to frequency
export ptof = |pitch| A4_FREQ * 2 ^ ((pitch - A4) / 12)

# frequency to pitch
export ftop = |freq| (12 * log2(freq / A4_FREQ)) + A4

# samples to frequency
export stof = |samples| samples / sr

# frequency to samples
export ftos = |freq| freq * sr

# milliseconds to samples
export mstos = |ms| (ms / 1000) * sr

# samples to milliseconds
export stoms = |samples| (samples / sr) * 1000

# bipolar to unipolar
export btou = |x| x + 1 * 0.5

# unipolar to bipolar
export utob = |x| x - 1 * 2 

export mix = |xs| 
  xs.fold 0, |acc, x| x * (1 / xs.count()) + acc

# 
# fx
#
export rev = |x, mix = 0.5 | 
  (x * (1 - mix)) + ((x -> reverb) * mix)

export flanger = |x, mix = 0.5, amt = 0.5, speed = 0.1| 
  dry = x * (1 - mix)
  wet = (((x -> delay (lfo speed) * (amt * 1000)) + x) * 0.5) * mix
  dry + wet

#
# synthesis
#
export pluck = |t, pitch, length = 1, damping = 0.5|
  period = freq_to_period (ptof pitch)
  noise() * ar 500, t -> echo period, length, damping

# hihat
export hh = |t, curve = 3| 
  noise() * (t -> ramp_rev -> pow curve) -> hp 8000, 0.5

#
# randomness
#

# output a random value between 0 and 1 on every trigger
rand = |t| noise() -> sh t -> btou

# bernoulli gate, outputs 1 with probability `prob` on every trigger
bernoulli = |t, prob = 0.5| 
  # TODO: clip prob between 0 and 1
  t -> mul (t -> rand -> lt prob)

